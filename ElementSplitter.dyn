{
  "Uuid": "f36ddf5d-f85c-4519-b70c-645b6c43f1aa",
  "IsCustomNode": false,
  "Description": null,
  "Name": "ElementSplitter",
  "ElementResolver": {
    "ResolutionMap": {}
  },
  "Inputs": [],
  "Outputs": [],
  "Nodes": [
    {
      "ConcreteType": "Dynamo.Nodes.DSModelElementsSelection, DSRevitNodesUI",
      "NodeType": "ExtensionNode",
      "InstanceId": [
        "a1e200c5-a8ce-4b74-9c19-fb2c2d35a860-000463e5",
        "a1e200c5-a8ce-4b74-9c19-fb2c2d35a860-00046415",
        "3a129a0a-dcff-4033-808e-75413f90a9d0-00049449"
      ],
      "Id": "b344bca634e843c9b56662ad23e52a4b",
      "Inputs": [],
      "Outputs": [
        {
          "Id": "66768cebc63543d9b92f49571c6e9386",
          "Name": "Elements",
          "Description": "The selected elements.",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled"
    },
    {
      "ConcreteType": "PythonNodeModels.PythonNode, PythonNodeModels",
      "NodeType": "PythonScriptNode",
      "Code": "import clr\r\nclr.AddReference('ProtoGeometry')\r\nfrom Autodesk.DesignScript.Geometry import *\r\nfrom sys import path as sysPath\r\nsysPath.append(\"C:\\Program Files (x86)\\IronPython 2.7\\Lib\")\r\nimport math\r\n\r\n# Import DocumentManager and TransactionManager\r\nclr.AddReference(\"RevitServices\")\r\nimport RevitServices\r\nfrom RevitServices.Persistence import DocumentManager\r\nfrom RevitServices.Transactions import TransactionManager\r\n\r\n# Import RevitAPI\r\nclr.AddReference(\"RevitAPI\")\r\nimport Autodesk.Revit.DB as db\r\nclr.AddReference(\"RevitNodes\")\r\ndoc = DocumentManager.Instance.CurrentDBDocument\r\n\r\n\r\n# functions collecting side elements\r\ndef getListOfLevelIds(doc):\r\n    fltr = db.ElementCategoryFilter(db.BuiltInCategory.OST_Levels)\r\n    if (IN[1]):\r\n        allLevels = db.FilteredElementCollector(doc).WherePasses(fltr).WhereElementIsNotElementType().ToElements()\r\n    else:\r\n        allLevels = db.FilteredElementCollector(doc, doc.ActiveView.Id).WherePasses(fltr).WhereElementIsNotElementType().ToElements()\r\n    lst = list()\r\n    for level in sorted(allLevels, key=lambda x: x.Elevation):\r\n        lst.append(level.Id)\r\n    return lst\r\n\r\n# Dedicated class for opening which is hosted in a wall\r\nclass WallOpenings():\r\n\r\n    def __init__(self, levelsList, wall, doc):\r\n        self.levels = levelsList\r\n        self.wall = wall\r\n        self.doc = doc\r\n        self.getListOfOpeningsHostedInWall()\r\n        self.createDictionaryOpeningAndItsLevel()\r\n\r\n    # Deletes openings which are not in boundries of new/edited wall element\r\n    # TO DO function which allows to keep openings i.e. wall base level: lvl 2 \r\n    # offset - 2000 -> openings under level 2 will be deleted\r\n    def deleteOpeningsNotInWallRange(self):\r\n        wallBaseConstrainId = self.wall.get_Parameter(db.BuiltInParameter.WALL_BASE_CONSTRAINT).AsElementId()\r\n        wallBaseOffset = self.wall.get_Parameter(db.BuiltInParameter.WALL_BASE_OFFSET).AsDouble()\r\n        wallTopConstrain = self.wall.get_Parameter(db.BuiltInParameter.WALL_HEIGHT_TYPE).AsElementId()\r\n        wallTopOffset = self.wall.get_Parameter(db.BuiltInParameter.WALL_TOP_OFFSET).AsDouble()\r\n\r\n        wallBaseElevation = self.doc.GetElement(wallBaseConstrainId).Elevation + wallBaseOffset\r\n        wallTopElevation = self.doc.GetElement(wallTopConstrain).Elevation + wallTopOffset\r\n        for openingId in self.openingDictionary:\r\n            openingElevation = self.openingDictionary[openingId]\r\n            if openingElevation < wallBaseElevation or openingElevation > wallTopElevation:\r\n                TransactionManager.Instance.EnsureInTransaction(self.doc)\r\n                self.doc.Delete(openingId)\r\n                TransactionManager.Instance.TransactionTaskDone()\r\n           \r\n    # Creates list of openings elements ids and assigns it to allOpeningsId element\r\n    def getListOfOpeningsHostedInWall(self):\r\n        self.allOpeningsId = self.wall.GetDependentElements(db.ElementCategoryFilter(db.BuiltInCategory.OST_GenericModel))\r\n        \r\n    # Creates dictionary of openings. Pair is openingId : levelId\r\n    def createDictionaryOpeningAndItsLevel(self):\r\n        self.openingDictionary = {}\r\n        for openingId in self.allOpeningsId:\r\n            opening = doc.GetElement(openingId)\r\n            self.openingDictionary[openingId] = self.getElevationOfOpening(opening)\r\n        return self.openingDictionary\r\n\r\n    # Returns levelId of the closest to an opening\r\n    def getElevationOfOpening(self, opening):\r\n        openingLevelId = opening.LookupParameter(\"Level\").AsElementId()\r\n        openingLevel = self.doc.GetElement(openingLevelId)\r\n        index = self.levels.index(openingLevelId)\r\n        try:\r\n            openingGeneralElevation = openingLevel.Elevation + opening.LookupParameter(\"Elevation\").AsDouble()\r\n        except AttributeError:\r\n            openingGeneralElevation = openingLevel.Elevation + opening.LookupParameter(\"Elevation from Level\").AsDouble()\r\n        return openingGeneralElevation\r\n\r\n    # Gets level index in list of levels\r\n    def getLevelIndex(self, index, opening, openingGeneralElevation):\r\n        i = index\r\n        while i < len(self.levels):\r\n            levelElement = doc.GetElement(self.levels[i])\r\n            if levelElement.Elevation <= openingGeneralElevation:\r\n                index = i\r\n            else:\r\n                break\r\n            i += 1\r\n        return index\r\n\r\n\r\n# Abstract class - main class\r\nclass ElementSplitter():\r\n\r\n    def __init__(self, doc, element, levelsList):\r\n        self.doc = doc\r\n        self.element = element\r\n        self.levelsList = levelsList\r\n    \r\n    # Lanuch function which tries to modify offsets\r\n    def modifyLevelsAndOffsets(self):\r\n        self.tryToModifyBaseBoundries()\r\n        self.tryToModifyTopBoundries()\r\n    \r\n    # Gets data from splitting element\r\n    def getElementData(self):\r\n        self.param_Mark = self.element.LookupParameter(\"Mark\").AsString()\r\n    \r\n    # Sets basic parameters to newly created elements\r\n    def setElementData(self, element):\r\n        TransactionManager.Instance.EnsureInTransaction(self.doc)\r\n        try:\r\n            element.LookupParameter(\"Mark\").Set(self.param_Mark)\r\n        except:\r\n            pass\r\n        TransactionManager.Instance.TransactionTaskDone()\r\n    \r\n    # Copies element\r\n    def copyElement(self):\r\n        TransactionManager.Instance.EnsureInTransaction(self.doc)\r\n        element = db.ElementTransformUtils.CopyElement(self.doc, self.element.Id, db.XYZ(0,0,0))\r\n        TransactionManager.Instance.TransactionTaskDone()\r\n        return element\r\n\r\n    # Deletes element\r\n    def deleteOriginalElement(self):\r\n        TransactionManager.Instance.EnsureInTransaction(self.doc)\r\n        self.doc.Delete(self.element.Id)\r\n        TransactionManager.Instance.TransactionTaskDone()\r\n\r\n    # Additional element for columns with top offset\r\n    def additionalElementWhileTopOffset(self, index):\r\n        if self.getTopOffsetValue() != 0:\r\n            element = self.doc.GetElement(self.copyElement()[0])\r\n            self.setBaseOffsetValue(element, 0)\r\n            self.setTopOffsetValue(element, self.getTopOffsetValue())\r\n            self.setBaseConstraintLevelId(element, self.levelsList[index + 1])\r\n            self.setTopConstraintLevelId(element, self.levelsList[index + 1])\r\n            self.additionalModificationOfElement(element)\r\n            return element\r\n\r\n    # General function for splitting elements\r\n    def splitElement(self):\r\n        self.getElementData()\r\n        if self.isElementPossibleToSplit():\r\n            self.listOfElementsToJoin = list()\r\n            startLevelIndex = self.getIndexOfBaseLevel()\r\n            endLevelIndex = self.getIndexOfTopLevel()\r\n            for i in range(startLevelIndex, endLevelIndex):\r\n                elementToChange = self.doc.GetElement(self.copyElement()[0])\r\n                self.listOfElementsToJoin.append(elementToChange)\r\n                if i == startLevelIndex:\r\n                    self.setBaseOffsetValue(elementToChange, self.getBaseOffsetValue())\r\n                    self.setTopOffsetValue(elementToChange, 0)\r\n                elif i == endLevelIndex - 1:\r\n                    self.setBaseOffsetValue(elementToChange, 0)\r\n                    # optionaly two lines below might be replaced with:\r\n                    # self.setTopOffsetValue(elementToChange, self.getTopOffsetValue())\r\n                    self.setTopOffsetValue(elementToChange, 0)\r\n                    additionalElement = self.additionalElementWhileTopOffset(i)\r\n                    self.listOfElementsToJoin.append(additionalElement)\r\n                else:\r\n                    self.setBaseOffsetValue(elementToChange, 0)\r\n                    self.setTopOffsetValue(elementToChange, 0)\r\n                    self.setElementData(elementToChange)\r\n                self.setBaseConstraintLevelId(elementToChange, self.levelsList[i])\r\n                self.setTopConstraintLevelId(elementToChange, self.levelsList[i+1])\r\n                self.additionalModificationOfElement(elementToChange)\r\n            self.joinElementsInList()\r\n            self.deleteOriginalElement()\r\n    \r\n    # Joins list of elements \r\n    def joinElementsInList(self):\r\n        TransactionManager.Instance.EnsureInTransaction(self.doc)\r\n        for i in range(len(self.listOfElementsToJoin)-1):\r\n            try:\r\n                db.JoinGeometryUtils.JoinGeometry(self.doc, self.listOfElementsToJoin[i], self.listOfElementsToJoin[i + 1])\r\n            except:\r\n                pass\r\n        TransactionManager.Instance.TransactionTaskDone()\r\n\r\n\r\n    # Adds Additional modification to element or its subelements\r\n    def additionalModificationOfElement(self, elementToChange):\r\n        pass\r\n\r\n    # checks if element goes trought more than\r\n    def isElementPossibleToSplit(self):\r\n        self.modifyLevelsAndOffsets()\r\n        startLevelIndex = self.getIndexOfBaseLevel()\r\n        endLevelIndex = self.getIndexOfTopLevel()\r\n        if startLevelIndex + 1 == endLevelIndex:\r\n            return False\r\n        else:\r\n            return True\r\n        \r\n    # Calculates distance between levels\r\n    def getDistanceBetweenLevels(self, originalLevelIndex, newLevelIndex):\r\n        listOfLevels = self.convertListOfLevelIdsToElements()\r\n        return listOfLevels[originalLevelIndex].Elevation - listOfLevels[newLevelIndex].Elevation\r\n\r\n    # Converts list of levels ids to elements\r\n    def convertListOfLevelIdsToElements(self):\r\n        lst = list()\r\n        for levelId in self.levelsList:\r\n            lst.append(self.doc.GetElement(levelId))\r\n        return lst\r\n\r\n    # tries to modify element to set level as high as it is possible\r\n    # and reduce offset. Instead of situation: Level no 3 with offset 10m\r\n    # it changes elements base level ie. Level no 5 with offset -50cm \r\n    def tryToModifyTopBoundries(self):\r\n        lst = list()\r\n        levels = self.convertListOfLevelIdsToElements()\r\n        try:\r\n            index = self.getIndexOfTopLevel()\r\n            endLevelOffset = self.getTopOffsetValue()\r\n        # means it's unconnected wall so treat base constraint as top with \r\n        # offset as unconnected height +/- base offset value\r\n        except ValueError:\r\n            index = self.getIndexOfBaseLevel()\r\n            if self.getBaseOffsetValue() < 0:\r\n                endLevelOffset = self.getHeight() + self.getBaseOffsetValue()\r\n            else:\r\n                endLevelOffset = self.getHeight() - self.getBaseOffsetValue()\r\n        elementElevation = levels[index].Elevation + endLevelOffset\r\n        indexOfNewLevel = None\r\n        for i in range(len(levels)):\r\n            if levels[i].Elevation <= elementElevation:\r\n                indexOfNewLevel = i\r\n                lst.append(indexOfNewLevel)\r\n            else:\r\n                break\r\n        if indexOfNewLevel != None:\r\n            return self.setNewTopBoundries(index, indexOfNewLevel)\r\n\r\n    # Sets new top boundry for element\r\n    def setNewTopBoundries(self, levelIndex, newLevelIndex):\r\n        differenceInOffset = self.getDistanceBetweenLevels(levelIndex, newLevelIndex)\r\n        # if wall is unconnected\r\n        if self.getTopConstraintLevelId().IntegerValue == -1:\r\n            newOffset = self.getHeight() + self.getBaseOffsetValue() + differenceInOffset\r\n        # Top is constrained to level\r\n        else:\r\n            newOffset = self.getTopOffsetValue() + differenceInOffset\r\n        newLevelId = self.levelsList[newLevelIndex]\r\n        TransactionManager.Instance.EnsureInTransaction(doc)\r\n        self.setTopConstraintLevelId(self.element, newLevelId)\r\n        self.setTopOffsetValue(self.element, newOffset)\r\n        TransactionManager.Instance.TransactionTaskDone()\r\n\r\n    # tries to modify element to set level as low as it is possible\r\n    # and reduce offset. Instead of situation: Level no 3 with offset -10m\r\n    # it changes elements base level ie. Level no 0 with offset -50cm \r\n    def tryToModifyBaseBoundries(self):\r\n        index = self.getIndexOfBaseLevel()\r\n        startLevelId = self.getBaseConstraintLevelId()\r\n        startLevelOffset = self.getBaseOffsetValue()\r\n        levels = self.convertListOfLevelIdsToElements()\r\n        if index != 0:\r\n            indexOfNewLevel = None\r\n            for i in range(index, 0, -1):\r\n                lvlIndex = i - 1\r\n                if startLevelOffset <= (levels[lvlIndex].Elevation - levels[index].Elevation):\r\n                    indexOfNewLevel = lvlIndex\r\n                else:\r\n                    break\r\n            if indexOfNewLevel != None:\r\n                self.setNewBaseBoundries(index, indexOfNewLevel)\r\n\r\n    # Sets new base boundry for element\r\n    def setNewBaseBoundries(self, levelIndex, newLevelIndex):\r\n        differenceInOffset = self.getDistanceBetweenLevels(levelIndex, newLevelIndex)\r\n        newOffset = self.getBaseOffsetValue() + differenceInOffset\r\n        newLevelId = self.levelsList[newLevelIndex]\r\n        TransactionManager.Instance.EnsureInTransaction(doc)\r\n        self.setBaseConstraintLevelId(self.element, newLevelId)\r\n        self.setBaseOffsetValue(self.element, newOffset)\r\n        TransactionManager.Instance.TransactionTaskDone()\r\n    \r\n    # Returns index of top level on the list of levels\r\n    def getIndexOfTopLevel(self):\r\n        endLevelId = self.getTopConstraintLevelId()\r\n        return self.levelsList.index(endLevelId)\r\n\r\n    # Returns index of base level on the list of levels\r\n    def getIndexOfBaseLevel(self):\r\n        startLevelId = self.getBaseConstraintLevelId()\r\n        return self.levelsList.index(startLevelId)\r\n\r\n\r\n# Class for walls\r\nclass WallSplitter(ElementSplitter):\r\n\r\n#GETTERS\r\n\r\n    # Returns base constraint levelId\r\n    def getBaseConstraintLevelId(self):\r\n        return self.element.get_Parameter(db.BuiltInParameter.WALL_BASE_CONSTRAINT).AsElementId()\r\n\r\n    # Returns base offset value\r\n    def getBaseOffsetValue(self):\r\n        return self.element.get_Parameter(db.BuiltInParameter.WALL_BASE_OFFSET).AsDouble()\r\n\r\n    # Returns unconnected height\r\n    def getHeight(self):\r\n        return self.element.get_Parameter(db.BuiltInParameter.WALL_USER_HEIGHT_PARAM).AsDouble()\r\n\r\n    # Returns top constraint levelId\r\n    def getTopConstraintLevelId(self):\r\n        return self.element.get_Parameter(db.BuiltInParameter.WALL_HEIGHT_TYPE).AsElementId()\r\n\r\n    # Returns top offset value\r\n    def getTopOffsetValue(self):\r\n        return self.element.get_Parameter(db.BuiltInParameter.WALL_TOP_OFFSET).AsDouble()\r\n\r\n# SETTERS\r\n\r\n    # Void, sets base constraint level based on level Id\r\n    def setBaseConstraintLevelId(self, element, levelId):\r\n        element.get_Parameter(db.BuiltInParameter.WALL_BASE_CONSTRAINT).Set(levelId)\r\n\r\n    # Void,sets base offset based on value\r\n    def setBaseOffsetValue(self, element, value):\r\n        element.get_Parameter(db.BuiltInParameter.WALL_BASE_OFFSET).Set(value)\r\n\r\n    # Void, sets top constraint level based on level Id\r\n    def setTopConstraintLevelId(self, element, levelId):\r\n        element.get_Parameter(db.BuiltInParameter.WALL_HEIGHT_TYPE).Set(levelId)\r\n\r\n    # Void,sets top offset based on value\r\n    def setTopOffsetValue(self, element, value):\r\n        element.get_Parameter(db.BuiltInParameter.WALL_TOP_OFFSET).Set(value)\r\n\r\n    # Due to openings neccessary to develop additional function\r\n    def additionalModificationOfElement(self, elementToChange):\r\n        objectOfOpenings = WallOpenings(self.levelsList, elementToChange, self.doc)\r\n        objectOfOpenings.deleteOpeningsNotInWallRange()\r\n\r\n\r\n# Class for structural columns and columns\r\nclass ColumnSplitter(ElementSplitter):\r\n\r\n#GETTERS\r\n\r\n    # Returns base constraint\r\n    def getBaseConstraintLevelId(self):\r\n        return self.element.get_Parameter(db.BuiltInParameter.FAMILY_BASE_LEVEL_PARAM).AsElementId()\r\n\r\n    def getBaseOffsetValue(self):\r\n        return self.element.get_Parameter(db.BuiltInParameter.FAMILY_BASE_LEVEL_OFFSET_PARAM).AsDouble()\r\n\r\n    # Returns unconnected height\r\n    def getHeight(self):\r\n        return self.element.LookupParameter(\"Length\").AsDouble()\r\n\r\n    # Returns top constraint levelId\r\n    def getTopConstraintLevelId(self):\r\n        return self.element.get_Parameter(db.BuiltInParameter.FAMILY_TOP_LEVEL_PARAM).AsElementId()\r\n\r\n    # Returns top offset value\r\n    def getTopOffsetValue(self):\r\n        return self.element.get_Parameter(db.BuiltInParameter.FAMILY_TOP_LEVEL_OFFSET_PARAM).AsDouble()\r\n\r\n# SETTERS\r\n\r\n    # Void, sets base constraint level based on level Id\r\n    def setBaseConstraintLevelId(self, element, levelId):\r\n        element.get_Parameter(db.BuiltInParameter.FAMILY_BASE_LEVEL_PARAM).Set(levelId)\r\n\r\n    # Void,sets base offset based on value\r\n    def setBaseOffsetValue(self, element, value):\r\n        element.get_Parameter(db.BuiltInParameter.FAMILY_BASE_LEVEL_OFFSET_PARAM).Set(value)\r\n\r\n    # Void, sets top constraint level based on level Id\r\n    def setTopConstraintLevelId(self, element, levelId):\r\n        element.get_Parameter(db.BuiltInParameter.FAMILY_TOP_LEVEL_PARAM).Set(levelId)\r\n\r\n    # Void,sets top offset based on value\r\n    def setTopOffsetValue(self, element, value):\r\n        element.get_Parameter(db.BuiltInParameter.FAMILY_TOP_LEVEL_OFFSET_PARAM).Set(value)\r\n\r\n\r\n# Class for slanted columns\r\nclass SlantedColumnSplitter(ColumnSplitter):\r\n\r\n#GETTERS  - inherits from parent\r\n    \r\n    # Gets data from splitting element\r\n    def getElementData(self):\r\n        self.param_Mark = self.element.LookupParameter(\"Mark\").AsString()\r\n        self.param_BaseCutStyle = self.element.get_Parameter(db.BuiltInParameter.SLANTED_COLUMN_BASE_CUT_STYLE).AsInteger()\r\n        self.param_TopCutStyle = self.element.get_Parameter(db.BuiltInParameter.SLANTED_COLUMN_TOP_CUT_STYLE).AsInteger()\r\n\r\n# SETTERS - inherits from parent\r\n    \r\n    # Sets basic parameters to newly created elements\r\n    def setElementData(self, element):\r\n        TransactionManager.Instance.EnsureInTransaction(self.doc)\r\n        try:\r\n            element.LookupParameter(\"Mark\").Set(self.param_Mark)\r\n        # pass while mark == None\r\n        except TypeError:\r\n            pass\r\n        element.get_Parameter(db.BuiltInParameter.SLANTED_COLUMN_BASE_CUT_STYLE).Set(self.param_BaseCutStyle)\r\n        element.get_Parameter(db.BuiltInParameter.SLANTED_COLUMN_TOP_CUT_STYLE).Set(self.param_TopCutStyle)\r\n        TransactionManager.Instance.TransactionTaskDone()\r\n\r\n    # Gets difference between start and end point Z Coordinate\r\n    def getElementVerticalHeight(self, element):\r\n        if type(element) == db.ElementId:\r\n            element = self.doc.GetElement(element)\r\n        elementCurve = element.Location.Curve\r\n        return elementCurve.GetEndPoint(1).Z - elementCurve.GetEndPoint(0).Z\r\n\r\n    # Splits proper levels for elements which has offset different than 0\r\n    def setOffsetForLastElement(self, element, index, coefficient):\r\n        if round(coefficient, 3) > 0 and round(coefficient, 3) < 1:\r\n            self.setBaseConstraintLevelId(element, self.levelsList[index + 1])\r\n            self.setTopConstraintLevelId(element, self.levelsList[index + 1])\r\n        else:\r\n            self.setBaseConstraintLevelId(element, self.levelsList[index])\r\n            self.setTopConstraintLevelId(element, self.levelsList[index + 1])\r\n    \r\n    # splits slantedColumnIntoTwoElements\r\n    def splitColumnIntoTwoElements(self, element, index, coefficinet):\r\n        oldElement = element\r\n        if round(coefficinet, 3) > 0 and round(coefficinet, 3) < 1:\r\n                TransactionManager.Instance.EnsureInTransaction(self.doc)\r\n                elementBeingSplit = self.doc.GetElement(element.Split(coefficinet))\r\n                TransactionManager.Instance.TransactionTaskDone()\r\n                self.setBaseConstraintLevelId(oldElement, self.levelsList[index])\r\n                self.setTopConstraintLevelId(oldElement, self.levelsList[index + 1])\r\n                self.setElementData(oldElement)\r\n                return elementBeingSplit\r\n        else:\r\n            return element\r\n\r\n    # Splits slanted column\r\n    def splitElement(self):\r\n        self.getElementData()\r\n        if self.isElementPossibleToSplit():\r\n            startLevelIndex = self.getIndexOfBaseLevel()\r\n            endLevelIndex = self.getIndexOfTopLevel()\r\n            elementBeingSplit = self.element\r\n            for i in range(startLevelIndex, endLevelIndex):\r\n                splitedElementLength = self.getElementVerticalHeight(elementBeingSplit)\r\n                if i == startLevelIndex:\r\n                    segmentLen = self.doc.GetElement(self.levelsList[i+1]).Elevation - self.doc.GetElement(self.levelsList[i]).Elevation - self.getBaseOffsetValue()\r\n                elif i == endLevelIndex - 1:\r\n                    segmentLen = self.doc.GetElement(self.levelsList[i+1]).Elevation - self.doc.GetElement(self.levelsList[i]).Elevation + self.getTopOffsetValue()\r\n                else:\r\n                    segmentLen = self.doc.GetElement(self.levelsList[i+1]).Elevation - self.doc.GetElement(self.levelsList[i]).Elevation\r\n                coefficientOfSplitting = segmentLen/splitedElementLength\r\n                elementBeingSplit = self.splitColumnIntoTwoElements(elementBeingSplit, i, coefficientOfSplitting)\r\n            self.setOffsetForLastElement(elementBeingSplit, i, coefficientOfSplitting)\r\n            self.setElementData(elementBeingSplit)\r\n\r\n\r\n# Abstract class for MEP elements which is inherited by certain MEP categories\r\nclass MepSplitter(ElementSplitter):\r\n    \r\n    # Splits slanted column\r\n    def splitElement(self):\r\n        elementsToAssignProperLevel = list()\r\n        levels = self.convertListOfLevelIdsToElements()\r\n        if not self.isElementPossibleToSplit():\r\n            return None\r\n        elementToSplit = self.element\r\n        elementsToAssignProperLevel.append(elementToSplit)\r\n        for level in levels:\r\n            levelElevation = level.Elevation\r\n            if elementToSplit == None:\r\n                break\r\n            elif levelElevation > self.startPoint.Z and levelElevation + 0.01 < self.endPoint.Z:\r\n                elementToSplit = self.splitVerticalElement(elementToSplit, level, levels)\r\n\r\n    # Assign levelId to each of MEP element in the list. levelId is assinged to level parameter of an element\r\n    def assignLevelsToElements(self, elements, levels):\r\n        for element in elements:\r\n            self.setBaseLevelToElement(element, levels)\r\n\r\n    # Assign levelId to an element. LevelId is assinged to level parameter of an element\r\n    def setBaseLevelToElement(self, element, levels):\r\n        elementCurve = element.Location.Curve\r\n        if self.elementLocationStyle == \"TopToDown\":\r\n            elementStartPoint = elementCurve.GetEndPoint(0)\r\n        else:\r\n            elementStartPoint = elementCurve.GetEndPoint(1)\r\n        return elementCurve.GetEndPoint(0)\r\n        for level in levels:\r\n            elevation = level.Elevation\r\n            if levels.index(level) == 0 and elementStartPoint < elevation:\r\n                self.setBaseConstraintLevelId(element, self.levelsList[0])\r\n\r\n    # Splits element but calculated point. Point Z coordinate is calculate base on level\r\n    def splitVerticalElement(self, elementToSplit, cutLevel, listOfLevels):\r\n        tempElementCurve = elementToSplit.Location.Curve\r\n        endPoint = tempElementCurve.GetEndPoint(1)\r\n        startPoint = tempElementCurve.GetEndPoint(0)\r\n        vectorFromStartPointToEndPoint = endPoint - startPoint\r\n        proportionOfDistanceToCutLocation = math.fabs(startPoint.Z - cutLevel.Elevation)/startPoint.DistanceTo(endPoint)\r\n        cutPoint = startPoint + vectorFromStartPointToEndPoint * proportionOfDistanceToCutLocation\r\n        return self.cutElementAndAssignUnionsPlusLevels(elementToSplit, cutPoint, listOfLevels)\r\n\r\n    # checkes if element is almost vertical, it check is horizontal distance ratio between top and down in order \r\n    # to vertical distance is less than 0.0001\r\n    def checkIfElementIsAlmostVertical(self):\r\n        verticalLength = math.fabs(self.endPoint.Z - self.startPoint.Z)\r\n        horizontalLength = math.sqrt(math.fabs(self.endPoint.X - self.startPoint.X)**2 + math.fabs(self.endPoint.Y - self.startPoint.Y)**2)\r\n        if horizontalLength/verticalLength <= 0.0001:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n    # checks style of a MEP element is it model from Top to Down or from Down to Top and assignes parameter\r\n    def isStartPointUpOrDown(self, originalStart, originalEnd):\r\n        if originalStart.Z > originalEnd.Z:\r\n            self.elementLocationStyle = \"TopToDown\"\r\n            self.startPoint = originalEnd\r\n            self.endPoint = originalStart\r\n        else:\r\n            self.elementLocationStyle = \"DownToTop\"\r\n            self.startPoint = originalStart\r\n            self.endPoint = originalEnd\r\n           \r\n\r\n    # checks if element goes trought more than\r\n    def isElementPossibleToSplit(self):\r\n        elementCurve = self.element.Location.Curve\r\n        self.isStartPointUpOrDown(elementCurve.GetEndPoint(0), elementCurve.GetEndPoint(1))\r\n        if not self.checkIfElementIsAlmostVertical():\r\n            return False\r\n        startPointLevelIndex = None\r\n        endPointLevelIndex = None\r\n        levels = self.convertListOfLevelIdsToElements()\r\n        for level in levels:\r\n            levelElevation = level.Elevation\r\n            if self.startPoint.Z < levelElevation and self.endPoint.Z > levelElevation + 0.01:\r\n                return True\r\n            else:\r\n                continue\r\n        if self.startPoint.Z < levelElevation and self.endPoint.Z > levelElevation + 0.01:\r\n                return True\r\n        return False\r\n\r\n    # tries to modify element to set level as low as it is possible\r\n    # and reduce offset. Instead of situation: Level no 3 with offset -10m\r\n    # it changes elements base level ie. Level no 0 with offset -50cm \r\n    \r\n    #GETTERS\r\n    # Returns base constraint levelId\r\n    def getBaseConstraintLevelId(self):\r\n        return self.element.get_Parameter(db.BuiltInParameter.RBS_START_LEVEL_PARAM).AsElementId()\r\n\r\n    # Returns base offset value\r\n    def getBaseOffsetValue(self):\r\n        return self.element.get_Parameter(db.BuiltInParameter.RBS_START_OFFSET_PARAM).AsDouble()\r\n\r\n    #SETTERS\r\n    # Void, sets base constraint level based on level Id\r\n    def setBaseConstraintLevelId(self, element, levelId):\r\n        TransactionManager.Instance.EnsureInTransaction(self.doc)\r\n        element.get_Parameter(db.BuiltInParameter.RBS_START_LEVEL_PARAM).Set(levelId)\r\n        TransactionManager.Instance.TransactionTaskDone()\r\n        return \r\n\r\n    # Sets new base boundry for element\r\n    def setNewBaseBoundries(self, levelIndex, newLevelIndex):\r\n        differenceInOffset = self.getDistanceBetweenLevels(levelIndex, newLevelIndex)\r\n        newLevelId = self.levelsList[newLevelIndex]\r\n        TransactionManager.Instance.EnsureInTransaction(doc)\r\n        self.setBaseConstraintLevelId(self.element, newLevelId)\r\n        TransactionManager.Instance.TransactionTaskDone()\r\n\r\n    # Adds MEP element union \r\n    def addUnion(self, newElement, elementToSplit):\r\n        newElementManager = newElement.ConnectorManager\r\n        oldElementManager = elementToSplit.ConnectorManager\r\n        for i in range(2):\r\n            for j in range(2):\r\n                newConnector = newElementManager.Lookup(i)\r\n                oldConnector = oldElementManager.Lookup(j)\r\n                if newConnector.Origin.IsAlmostEqualTo(oldConnector.Origin):\r\n                    TransactionManager.Instance.EnsureInTransaction(self.doc)\r\n                    union = self.doc.Create.NewUnionFitting(newConnector, oldConnector)\r\n                    TransactionManager.Instance.TransactionTaskDone()\r\n                    return union\r\n\r\n    # Assigns element to proper level\r\n    def assignProperLevelToElement(self, element, listOfLevels):\r\n        elementCurve = element.Location.Curve\r\n        startPoint = elementCurve.GetEndPoint(0).Z\r\n        endPoint = elementCurve.GetEndPoint(1).Z\r\n        for level in listOfLevels:\r\n            elevation = level.Elevation\r\n            if ((elevation + 0.01 >= startPoint and elevation - 0.01 <= startPoint) or\r\n            (elevation + 0.01 >= endPoint and elevation - 0.01 <= endPoint)):\r\n                levelIndex = listOfLevels.index(level)\r\n                if levelIndex != 0 and not (startPoint >= elevation and endPoint >= elevation):\r\n                    levelIndex = levelIndex - 1\r\n                break\r\n        self.setBaseConstraintLevelId(element, self.levelsList[levelIndex])\r\n\r\n    # function assings level to elements and adds union\r\n    # it's possible to opimize: not set parameters to splitting element after\r\n    # each iteration, but than unions will not be assigned to proper level \r\n    def assignElementsToLevelsAndAddUnion(self, newElement, elementToSplit, listOfLevels):\r\n        if elementToSplit != None:\r\n            self.assignProperLevelToElement(elementToSplit, listOfLevels)\r\n        if newElement != None:\r\n            self.assignProperLevelToElement(newElement, listOfLevels)\r\n        if newElement != None:\r\n            self.addUnion(newElement, elementToSplit)\r\n\r\n\r\n# Class for duct elements\r\nclass DuctSplitter(MepSplitter):\r\n\r\n    # Function splitting a duct into 2 elements\r\n    def cutElementAndAssignUnionsPlusLevels(self, elementToSplit, cutPoint, listOfLevels):\r\n        TransactionManager.Instance.EnsureInTransaction(self.doc)\r\n        try:\r\n            newElementId = db.Mechanical.MechanicalUtils.BreakCurve(self.doc, elementToSplit.Id, cutPoint)\r\n            newElement = self.doc.GetElement(newElementId)\r\n        except:\r\n            newElement = None\r\n        TransactionManager.Instance.TransactionTaskDone()\r\n        self.assignElementsToLevelsAndAddUnion(newElement, elementToSplit, listOfLevels)\r\n        if self.elementLocationStyle == \"TopToDown\":\r\n            return newElement\r\n        return elementToSplit\r\n\r\n# Class for pipes (plumbing elements - not Conduits)\r\nclass PipeSplitter(MepSplitter):\r\n\r\n    # Function splitting a duct into 2 elements\r\n    def cutElementAndAssignUnionsPlusLevels(self, elementToSplit, cutPoint, listOfLevels):\r\n        TransactionManager.Instance.EnsureInTransaction(self.doc)\r\n        try:\r\n            newElementId = db.Plumbing.PlumbingUtils.BreakCurve(self.doc, elementToSplit.Id, cutPoint)\r\n            newElement = self.doc.GetElement(newElementId)\r\n        except:\r\n            newElement = None\r\n        TransactionManager.Instance.TransactionTaskDone()\r\n        self.assignElementsToLevelsAndAddUnion(newElement, elementToSplit, listOfLevels)\r\n        if self.elementLocationStyle == \"TopToDown\":\r\n            return newElement\r\n        return elementToSplit\r\n\r\n\r\ndef getlistOfElements():\r\n    try:\r\n        numberOfElements = len(IN[0])\r\n        if numberOfElements > 1:\r\n            return IN[0]\r\n        else:\r\n            return [IN[0]]\r\n    except:\r\n        return [IN[0]]\r\n\r\nlevels = getListOfLevelIds(doc)\r\nfor element in getlistOfElements():\r\n    # converts dynamo element to revit element\r\n    try:\r\n    \trevitElement = doc.GetElement(db.ElementId(element.Id))\r\n    except AttributeError:\r\n    \tcontinue    \t\r\n    # gets revit element type\r\n    try:\r\n        elementType = revitElement.GetType()\r\n    except TypeError:\r\n        elementType = None\r\n    \r\n    element = None\r\n    if elementType == db.Wall:\r\n        element = WallSplitter(doc, revitElement, levels)\r\n    elif elementType == db.FamilyInstance:\r\n        structuralType = revitElement.StructuralType\r\n        if structuralType == db.Structure.StructuralType.Column and not revitElement.IsSlantedColumn:\r\n            element = ColumnSplitter(doc, revitElement, levels)\r\n        elif structuralType == db.Structure.StructuralType.Column and revitElement.IsSlantedColumn:\r\n            element = SlantedColumnSplitter(doc, revitElement, levels)\r\n    elif elementType == db.Mechanical.Duct:\r\n        element = DuctSplitter(doc, revitElement, levels)\r\n    elif elementType == db.Plumbing.Pipe:\r\n        element = PipeSplitter(doc, revitElement, levels)\r\n    if element != None:\r\n        element.splitElement()\r\nOUT = \"done\"",
      "VariableInputPorts": true,
      "Id": "1a1b73be4df9457298e13d9fbb1ec5dc",
      "Inputs": [
        {
          "Id": "51d5b7d47f3e43ed9e674015fbaeeb75",
          "Name": "IN[0]",
          "Description": "Input #0",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        },
        {
          "Id": "c7ef63d7537f4d739938a5eb0f4a5ac0",
          "Name": "IN[1]",
          "Description": "Input #1",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Outputs": [
        {
          "Id": "7c552860f02d4b7aa4735104379acb2f",
          "Name": "OUT",
          "Description": "Result of the python script",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Runs an embedded IronPython script."
    },
    {
      "ConcreteType": "CoreNodeModels.Input.BoolSelector, CoreNodeModels",
      "NodeType": "BooleanInputNode",
      "InputValue": true,
      "Id": "d16f6f1cec3e4fdc96ed925e48597c39",
      "Inputs": [],
      "Outputs": [
        {
          "Id": "3ba197594750457988b1360afeb0f3b1",
          "Name": "",
          "Description": "Boolean",
          "UsingDefaultValue": false,
          "Level": 2,
          "UseLevels": false,
          "KeepListStructure": false
        }
      ],
      "Replication": "Disabled",
      "Description": "Selection between a true and false."
    }
  ],
  "Connectors": [
    {
      "Start": "66768cebc63543d9b92f49571c6e9386",
      "End": "51d5b7d47f3e43ed9e674015fbaeeb75",
      "Id": "d70400151a80412cadaed727b873a27a"
    },
    {
      "Start": "3ba197594750457988b1360afeb0f3b1",
      "End": "c7ef63d7537f4d739938a5eb0f4a5ac0",
      "Id": "aa7c3fea2efc444f975c31b538bf56e9"
    }
  ],
  "Dependencies": [],
  "NodeLibraryDependencies": [],
  "Bindings": [],
  "View": {
    "Dynamo": {
      "ScaleFactor": 1.0,
      "HasRunWithoutCrash": true,
      "IsVisibleInDynamoLibrary": true,
      "Version": "2.5.0.7460",
      "RunType": "Manual",
      "RunPeriod": "1000"
    },
    "Camera": {
      "Name": "Background Preview",
      "EyeX": -17.0,
      "EyeY": 24.0,
      "EyeZ": 50.0,
      "LookX": 12.0,
      "LookY": -13.0,
      "LookZ": -58.0,
      "UpX": 0.0,
      "UpY": 1.0,
      "UpZ": 0.0
    },
    "NodeViews": [
      {
        "ShowGeometry": true,
        "Name": "Select Model Elements",
        "Id": "b344bca634e843c9b56662ad23e52a4b",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "X": 332.38138854745858,
        "Y": 376.00827590323297
      },
      {
        "ShowGeometry": true,
        "Name": "Python Script",
        "Id": "1a1b73be4df9457298e13d9fbb1ec5dc",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "X": 827.40918122119137,
        "Y": 476.49064289411905
      },
      {
        "ShowGeometry": true,
        "Name": "True = Split by all levels. False = Split by visible levels in 3D",
        "Id": "d16f6f1cec3e4fdc96ed925e48597c39",
        "IsSetAsInput": false,
        "IsSetAsOutput": false,
        "Excluded": false,
        "X": 329.49389910937725,
        "Y": 603.09516101857389
      }
    ],
    "Annotations": [
      {
        "Id": "134d92976b7f4921b18a349c255ea53a",
        "Title": "Not available now (not working for cases when top/base constrain in list of hidden levels)",
        "Nodes": [],
        "Left": 330.20275355415532,
        "Top": 555.718838740238,
        "Width": 0.0,
        "Height": 0.0,
        "FontSize": 36.0,
        "InitialTop": 0.0,
        "InitialHeight": 0.0,
        "TextblockHeight": 0.0,
        "Background": "#FFC1D676"
      }
    ],
    "X": -209.94348752226119,
    "Y": 125.36651867060152,
    "Zoom": 0.84328771079912279
  }
}